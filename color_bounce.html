<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Color Dot Catcher Game</title>
<style>
  html, body {
    margin: 0; padding: 0; height: 100%;
    background: linear-gradient(135deg, #141e30, #243b55);
    overflow: hidden;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: white;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
  }
  #scoreboard {
    font-size: 2rem;
    margin: 15px;
    text-shadow: 0 0 8px #000;
  }
  canvas {
    display: block;
    background: linear-gradient(135deg, #141e30, #243b55);
    border-radius: 12px;
    box-shadow: 0 0 30px #0f4c81;
    max-width: 100vw;
    max-height: 80vh;
  }
  #instructions {
    font-size: 1rem;
    max-width: 600px;
    padding: 10px 20px;
    text-align: center;
    color: #ccc;
    user-select: none;
  }
</style>
</head>
<body>

<div id="scoreboard">Score: 0</div>
<canvas id="gameCanvas"></canvas>
<div id="instructions">
  Use <strong>WASD</strong> or <strong>Arrow keys</strong> to move.<br/>
  Catch falling dots to score points. The faster you catch, the faster dots fall!
</div>

<script>
  (() => {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Responsive sizing
    function resize() {
      canvas.width = window.innerWidth * 0.95;
      canvas.height = window.innerHeight * 0.7;
    }
    window.addEventListener('resize', resize);
    resize();

    // Player setup
    const player = {
      x: canvas.width / 2,
      y: canvas.height - 50,
      radius: 30,
      color: '#00fff7',
      speed: 6,
      dx: 0,
      dy: 0,
    };

    // Falling dots
    const dots = [];
    const dotRadius = 15;

    // Game state
    let score = 0;
    let dotSpeed = 2;
    let spawnInterval = 1200; // ms
    let lastSpawn = 0;

    // Keys pressed
    const keys = {};

    window.addEventListener('keydown', e => {
      keys[e.code] = true;
    });
    window.addEventListener('keyup', e => {
      keys[e.code] = false;
    });

    // Touch controls: left/right halves of canvas
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      const touchX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
      if (touchX < canvas.width / 2) {
        keys.ArrowLeft = true;
        keys.ArrowRight = false;
      } else {
        keys.ArrowRight = true;
        keys.ArrowLeft = false;
      }
    }, { passive: false });

    canvas.addEventListener('touchend', e => {
      e.preventDefault();
      keys.ArrowLeft = false;
      keys.ArrowRight = false;
    }, { passive: false });

    // Draw player
    function drawPlayer() {
      ctx.beginPath();
      const gradient = ctx.createRadialGradient(player.x, player.y, player.radius*0.3, player.x, player.y, player.radius);
      gradient.addColorStop(0, player.color);
      gradient.addColorStop(1, '#005f62');
      ctx.fillStyle = gradient;
      ctx.shadowColor = player.color;
      ctx.shadowBlur = 20;
      ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.closePath();
    }

    // Draw dots
    function drawDot(dot) {
      ctx.beginPath();
      const gradient = ctx.createRadialGradient(dot.x, dot.y, dot.radius*0.3, dot.x, dot.y, dot.radius);
      gradient.addColorStop(0, dot.color);
      gradient.addColorStop(1, '#000');
      ctx.fillStyle = gradient;
      ctx.shadowColor = dot.color;
      ctx.shadowBlur = 15;
      ctx.arc(dot.x, dot.y, dot.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.closePath();
    }

    // Create a random colored dot at the top with random X
    function spawnDot() {
      const colors = ['#ff3c78', '#ffad33', '#8c33ff', '#33ffbd', '#33d1ff'];
      const color = colors[Math.floor(Math.random() * colors.length)];
      const x = Math.random() * (canvas.width - 2 * dotRadius) + dotRadius;
      dots.push({ x, y: -dotRadius, radius: dotRadius, color });
    }

    // Update player position based on keys pressed
    function updatePlayer() {
      player.dx = 0;
      if (keys.KeyA || keys.ArrowLeft) player.dx = -player.speed;
      if (keys.KeyD || keys.ArrowRight) player.dx = player.speed;

      player.x += player.dx;

      // Keep inside canvas
      if (player.x < player.radius) player.x = player.radius;
      if (player.x > canvas.width - player.radius) player.x = canvas.width - player.radius;
    }

    // Update dots position and check collisions
    function updateDots(deltaTime) {
      for (let i = dots.length - 1; i >= 0; i--) {
        const dot = dots[i];
        dot.y += dotSpeed;

        // Remove if off bottom
        if (dot.y - dot.radius > canvas.height) {
          dots.splice(i, 1);
          continue;
        }

        // Check collision with player (circle collision)
        const dist = Math.hypot(dot.x - player.x, dot.y - player.y);
        if (dist < dot.radius + player.radius) {
          dots.splice(i, 1);
          score++;
          updateScore();
          increaseDifficulty();
        }
      }
    }

    // Update scoreboard UI
    function updateScore() {
      document.getElementById('scoreboard').textContent = `Score: ${score}`;
    }

    // Increase difficulty gradually
    function increaseDifficulty() {
      if (score % 5 === 0) {
        dotSpeed += 0.5;
        spawnInterval = Math.max(400, spawnInterval - 100);
      }
    }

    // Game loop
    let lastTime = performance.now();

    function gameLoop(time) {
      const deltaTime = time - lastTime;
      lastTime = time;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      updatePlayer();
      updateDots(deltaTime);

      drawPlayer();
      dots.forEach(drawDot);

      // Spawn new dots
      if (time - lastSpawn > spawnInterval) {
        spawnDot();
        lastSpawn = time;
      }

      requestAnimationFrame(gameLoop);
    }

    // Start the game
    updateScore();
    requestAnimationFrame(gameLoop);
  })();
</script>

</body>
</html>
