<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Realistic Ghost Chase - Three.js</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #121212; }
    #info {
      position: absolute; top: 10px; width: 100%; text-align: center;
      color: white; font-family: Arial, sans-serif; font-size: 18px;
      user-select: none; z-index: 1;
    }
  </style>
</head>
<body>
  <div id="info">Use WASD / Arrow Keys to move the human. Escape the glowing ghost!</div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // Scene setup
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x121212, 0.06);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 3, 8);

    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Lighting
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    hemiLight.position.set(0, 20, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 7);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    dirLight.shadow.camera.left = -10;
    dirLight.shadow.camera.right = 10;
    dirLight.shadow.camera.top = 10;
    dirLight.shadow.camera.bottom = -10;
    scene.add(dirLight);

    // Ground
    const groundMat = new THREE.MeshStandardMaterial({color: 0x222222});
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(50, 50), groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Controls (for debug, optional)
    // const controls = new THREE.OrbitControls(camera, renderer.domElement);

    // Loaders
    const loader = new THREE.GLTFLoader();

    // Variables
    let human, mixer, actions = {}, activeAction, previousAction;
    let clock = new THREE.Clock();

    // Movement parameters
    const move = { forward: false, backward: false, left: false, right: false };
    const walkSpeed = 2.5;
    const runSpeed = 5;

    // Load Human Model with animations (Mixamo)
    // Model URL (GLTF + animations) from a public source
    // Note: This is a generic adult male model with walk/run/idle animations combined
    loader.load('https://threejs.org/examples/models/gltf/Xbot.glb', gltf => {
      human = gltf.scene;
      human.traverse(function(child){
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });

      human.scale.set(0.01, 0.01, 0.01); // Scale down
      human.position.set(0, 0, 0);
      scene.add(human);

      mixer = new THREE.AnimationMixer(human);

      // Extract animations by name
      gltf.animations.forEach((clip) => {
        actions[clip.name] = mixer.clipAction(clip);
      });

      // Play idle initially
      activeAction = actions['Idle'] || actions[Object.keys(actions)[0]];
      activeAction.play();

      animate();
    });

    // Ghost: glowing transparent sphere with slight bobbing
    const ghostMaterial = new THREE.MeshStandardMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.4,
      emissive: 0x00ffff,
      emissiveIntensity: 1,
      roughness: 0.1,
      metalness: 0.5
    });
    const ghostGeometry = new THREE.SphereGeometry(0.6, 32, 32);
    const ghost = new THREE.Mesh(ghostGeometry, ghostMaterial);
    ghost.position.set(5, 1, -5);
    ghost.castShadow = true;
    scene.add(ghost);

    // Ghost light halo
    const ghostLight = new THREE.PointLight(0x00ffff, 1, 6);
    ghostLight.position.copy(ghost.position);
    scene.add(ghostLight);

    // Player position & velocity
    const playerPosition = new THREE.Vector3();
    const playerVelocity = new THREE.Vector3();

    // Ghost AI speed
    const ghostSpeed = 1.5;

    // Keyboard controls
    window.addEventListener('keydown', e => {
      switch (e.code) {
        case 'ArrowUp':
        case 'KeyW':
          move.forward = true; break;
        case 'ArrowDown':
        case 'KeyS':
          move.backward = true; break;
        case 'ArrowLeft':
        case 'KeyA':
          move.left = true; break;
        case 'ArrowRight':
        case 'KeyD':
          move.right = true; break;
      }
    });
    window.addEventListener('keyup', e => {
      switch (e.code) {
        case 'ArrowUp':
        case 'KeyW':
          move.forward = false; break;
        case 'ArrowDown':
        case 'KeyS':
          move.backward = false; break;
        case 'ArrowLeft':
        case 'KeyA':
          move.left = false; break;
        case 'ArrowRight':
        case 'KeyD':
          move.right = false; break;
      }
    });

    // Helper function to switch animation smoothly
    function fadeToAction(name, duration = 0.3) {
      previousAction = activeAction;
      activeAction = actions[name];
      if (previousAction !== activeAction) {
        previousAction.fadeOut(duration);
        activeAction.reset().fadeIn(duration).play();
      }
    }

    // Game state
    let gameOver = false;
    const escapeDistance = 2;

    // Game loop
    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();

      if (mixer) mixer.update(delta);

      if (!human || gameOver) {
        renderer.render(scene, camera);
        return;
      }

      // Movement vector
      let direction = new THREE.Vector3();
      if (move.forward) direction.z -= 1;
      if (move.backward) direction.z += 1;
      if (move.left) direction.x -= 1;
      if (move.right) direction.x += 1;
      direction.normalize();

      // Set animation & speed based on input
      if (direction.length() === 0) {
        fadeToAction('Idle');
      } else {
        fadeToAction('Walk');
      }

      // Move human
      const speed = walkSpeed;
      human.position.x += direction.x * speed * delta;
      human.position.z += direction.z * speed * delta;

      // Rotate human to movement direction
      if (direction.length() > 0) {
        const angle = Math.atan2(direction.x, direction.z);
        human.rotation.y = angle;
      }

      // Update player position vector for ghost AI
      playerPosition.copy(human.position);

      // Ghost bobbing
      ghost.position.y = 1 + Math.sin(Date.now() * 0.003) * 0.2;

      // Ghost moves towards player
      let ghostDir = new THREE.Vector3().subVectors(playerPosition, ghost.position);
      const dist = ghostDir.length();

      if (dist > escapeDistance) {
        ghostDir.normalize();
        ghost.position.addScaledVector(ghostDir, ghostSpeed * delta);
        ghostLight.position.copy(ghost.position);
      } else {
        gameOver = true;
        alert('The ghost caught you! Refresh to try again.');
      }

      // Camera follows human with smooth lag
      const camTargetPos = new THREE.Vector3(human.position.x, human.position.y + 2, human.position.z + 6);
      camera.position.lerp(camTargetPos, 0.05);
      camera.lookAt(human.position.x, human.position.y + 1, human.position.z);

      renderer.render(scene, camera);
    }

    // Handle window resizing
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
